Журналирование PostgreSQL
# Материалы:
    [Карта видимости](https://postgrespro.ru/docs/postgrespro/12/storage-vm)
    [Карта свободного пространства](https://postgrespro.ru/docs/postgrespro/12/storage-fsm)\
    [WAL в PostgreSQL: 1. Буферный кеш](https://habr.com/ru/companies/postgrespro/articles/458186/)
    [WAL в PostgreSQL: 2. Журнал предзаписи](https://habr.com/ru/companies/postgrespro/articles/459250/)
    [WAL в PostgreSQL: 3. Контрольная точка](https://habr.com/ru/companies/postgrespro/articles/460423/)
    [WAL в PostgreSQL: 4. Настройка журнала](https://habr.com/ru/companies/postgrespro/articles/461523/)
    [Записки угрюмого поднимателя пингвинов.](http://www.zaweel.ru/2016/07/postgresql_22.html#настройка-systemdb)
    [Deep dive into PostgreSQL internal statistics. Алексей Лесовский](https://habr.com/ru/articles/505440/)
    [Включение ведения контрольных сумм в кластере PostgreSQL 12](https://blog.programs74.ru/how-to-enable-checksums-in-postgresql/)
    [Калькулятор настроек](https://ottertune.com/)
    https://pgtune.leopard.in.ua/
    https://stackoverflow.com/questions/58909125/postgres-auto-tuning

# Буферный кэш
 ## Буферный кэш. Состав
    Каждый буфер состоит из одной страницы данных и заголовка. Размер по умолчанию 8 кб. Заголовок содержит:
        • расположение страницы на диске (файл и номер страницы в нем),
        • число обращений к буферу (счетчик увеличивается каждый раз, когда процесс читает или изменяет буфер, максимально значение 5),
        • признак того, что данные на странице изменились и рано или поздно должны быть записаны на диск (грязный буфер).
    Изначально кэш содержит:
        • пустые буферы, и все они связаны в список свободных буферов,
        • указатель на «следующую жертву» при вытеснении старых буферов,
        • также используется хеш-таблица, чтобы быстро находить нужную страницу в кэше.
    Размер буферного кэша задается параметром shared_buffers. Его изменение требует перезапуска сервера.
 ## Буферный кэш. Настройка.
    По умолчанию shared_buffers = 128MB
    Буферный кэш должен содержать «активные» данные:
    Начальная рекомендация — 25% ОЗУ
    Нужно учитывать двойное кэширование - если страницы нет в кэше
    СУБД, она может оказаться в кэше ОС, но алгоритм вытеснения ОС не
    учитывает специфики базы данных.
 ## Буферный кэш. Временные таблицы
    Данные временных таблиц
    • видны только одному сеансу — нет смысла использовать общий кэш
    • существуют в пределах сеанса — не жалко потерять при сбое
    Используется локальный буферный кэш
    • не требуются блокировки
    • память выделяется по необходимости в пределах temp_buffers
    • обычный алгоритм вытеснения

   # Представление pg_buffercache
      CREATE EXTENSION pg_buffercache;
      Представление pg_buffercache содержит:
         bufferid — ID блока в общем буфере;
         relfilenode — имя папки, где данные расположены;
         reltablespace — Oid таблицы;
         reldatabase — Oid базы данных;
         relforknumber — номер ответвления;
         relblocknumber — номер страницы;
         isdirty — грязная страница;
         usagecount — количество LRU страниц.

 ## Буферныйкэш. Разогрев кэша
    pg_prewarm
    • используется после рестарта кластера
    • заполняет кэш указанными таблицами
# Write aheadlog - WAL
 ## Основная задача
    • возможность восстановления согласованности данных после сбоя
 ## Механизм
    • при изменении данных действие также записывается в журнал журнальная запись попадает на диск раньше измененных данных
    • восстановление после сбоя — повторное выполнение потерянных операций с помощью журнальных записей
 ## Что туда попадает
    • изменение любых страниц в буферном кэше
    • фиксация и отмена транзакций - буферы XACT
    НЕ ПОПАДАЮТ - временные и нежурналируемые таблицы
 ## WAL.Восстановление
    при старте сервера после сбоя (состояние кластера в pg_control отличается от «shut down»):
    1. для каждой журнальной записи:
        ● определить страницу, к которой относится эта запись
        ● применить запись, если ее LSN больше, чем LSN страницы
    2. перезаписать нежурналируемые таблицы init-файлами
# Контрольная точка
 ## При старте сервера послесбоя
    1. найти LSN0 начала последней завершенной контрольной точки
    2. применить каждую запись журнала, начиная с LSN0 , если LSN записи
    больше, чем LSN страницы
    3. перезаписать нежурналируемые таблицы init-файлами
    4. выполнить контрольную точку
 ## Настройка частоты срабатывания:
    • checkpoint_timeout = 5min
    • max_wal_size = 1GB
    Сервер хранит журнальные файлы необходимые для восстановления:
    • (2 (1 с 12 версии) + checkpoint_completion_target) * max_wal_size
    • еще не прочитанные через слоты репликации
    • еще не записанные в архив, если настроена непрерывная архивация
    • не превышающие по объему минимальной отметки
   ### Настройки
    • max_wal_size = 1GB
    • min_wal_size = 100MB
    • wal_keep_segments = 0
 ## Контрольнаяточка. Процесс фоновой записи
   ### Настройки
    • bgwriter_delay = 200ms
    • bgwriter_lru_maxpages = 100
    • bgwriter_lru_multiplier = 2.0
   ### Алгоритм
    • уснуть на bgwriter_delay
    • если в среднем за цикл запрашивается N буферов, то записать N * bgwriter_lru_multiplier ≤ bgwriter_lru_maxpages грязных буферов
# Настрока журнала
 ## Уровни журнала
    Minimal - восстановление после сбоя
    Replica - восстановление из резервной копии, репликация    + операции массовой обработки данных, блокировки
    Logical - логическая репликация     + информация для логического декодирования
    Настройка
        wal_level = replica
# Настройка записи на диск
   ## Синхронизация сдиском
        данные должны дойти до энергонезависимого хранилища через многочисленные кэши
        СУБД сообщает операционной системе способом, указанным в wal_sync_method
        надо учитывать аппаратное кэширование
   ## Настройки
        fsync = on
        show fsync;
        show wal_sync_method;
        утилита pg_test_fsync помогает выбрать оптимальный способ
# Повреждение данных
   ## Контрольные суммы журнальных записей
        включены всегда, CRC-32
        Контрольные суммы страниц (накладные расходы)
         По умолчанию отключены. До 12 версии можно включить только при инициализации кластера.
        pg_createcluster --data-checksums
   ## Настройки
        show data_checksums;
        ignore_checksum_failure = off
        wal_log_hints = off (записывает все содержимое каждой страницы при
        измениях даже инф.бит, неявно on при контрольных суммах страниц)
        wal_compression = off
 # Характер нагрузки
   ## Постоянный поток записи
        ● характер нагрузки отличается от остальной системы
        ● последовательная запись, отсутствие случайного доступа
        ● при высокой нагрузке — размещение на отдельных физических дисках (символьная ссылка из $PGDATA/pg_wal)
   ## Редкое чтение
        ● при восстановлении
        ● при работе процессов walsender, если реплика не успевает быстро получать записи
 # Режимы записи
    ● синхронный режим
    ● асинхронный режим
    [wal_sync_method](https://postgresqlco.nf/doc/ru/param/wal_sync_method/)
  ## Режим синхронной записи
   ### Алгоритм
        ● при фиксации изменений сбрасывает накопившиеся записи, включая запись о фиксации
        ● ждет commit_delay, если активно не менее commit_siblings транзакций
   ### Характеристики
        ● гарантируется долговечность
        ● увеличивается время отклика
   ### Настройки
        ● synchronous_commit = on
        ● commit_delay = 0
        ● commit_siblings = 5
  ## Режим асинхронной записи
   ### Алгоритм
        ● циклы записи через wal_writer_delay
        ● записывает только целиком заполненные страницы
        ● но если новых полных страниц нет, то записывает последнюю до конца
   ### Характеристики
        ● гарантируется согласованность, но не долговечность
        ● зафиксированные изменения могут пропасть (3 × wal_writer_delay)
        ● уменьшается время отклика
   ### Настройки
        ● synchronous_commit = off (можно изменять на уровне транзакции)
        ● wal_writer_delay = 200ms



        $/usr/lib/postgresql/13/bin/pg_waldump -r list - список менеджеров

pg_ls_waldir() - показывает файлы WAL;
        SELECT * FROM pg_ls_waldir() LIMIT 50;

        

        Таблица 28.21. Представление pg_stat_bgwriter
checkpoints_timed - Количество запланированных контрольных точек, которые уже были выполнены
checkpoints_req - Количество запрошенных контрольных точек, которые уже были выполнены
checkpoint_write_time - Общее время, которое было затрачено на этап обработки контрольной точки, в котором файлы записываются на диск, в миллисекундах
checkpoint_sync_time - Общее время, которое было затрачено на этап обработки контрольной точки, в котором файлы синхронизируются с диском, в миллисекундах
buffers_checkpoint  - Количество буферов, записанных при выполнении контрольных точек
buffers_clean  - Количество буферов, записанных фоновым процессом записи
maxwritten_clean  - Сколько раз фоновый процесс записи останавливал сброс грязных страниц на диск из-за того, что записал слишком много буферов
buffers_backend  - Количество буферов, записанных самим серверным процессом
buffers_backend_fsync  - Сколько раз серверному процессу пришлось выполнить fsync самостоятельно (обычно фоновый процесс записи сам обрабатывает эти вызовы, даже когда серверный процесс выполняет запись самостоятельно)
buffers_alloc - Количество выделенных буферов
stats_reset - Последнее время сброса этих статистических данных